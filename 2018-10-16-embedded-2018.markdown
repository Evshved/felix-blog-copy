---
layout: post
title: "Embedded 2018"
date: 2018-10-16 20:58:01 +0300
categories: talk
---
Не сразу сформулировал словами, а сейчас решил уже доформулировать до эссе, расширив вопрос: а что может нравиться в embedded low level? Ответ напрочь лирический, состоит из двух причин. Причины, конечно, *мои*. Ещё я люблю пельмени, пиво и белый шоколад (что ни фига не шоколад).

Оставлю вне обсуждения темы количества, разнообразия и оплаты работы в этой области, оно (как и везде) ситуативно и колеблется от копейки до миллиона. Хочу про романтику. Чем оно может радовать, воодушевлять, восхищать, удивлять, удовлетворять. Также ограничу embedded до MCU категории "дорого-богато" (в районе [single-board ARM computers](https://en.wikipedia.org/wiki/Comparison_of_single-board_computers) (SBC) плюс-минус). Да, это удобный чит, который ставит под вопрос сам "термин" embedded, ибо остаётся всего шаг до *"ну а чё, давайте тогда разработку на Android запишем, там те же платы"*, но... есть какой-то психологический водораздел, пожалуй.

Ещё требуется обозначить low level, что тоже получится не строго. Допустим, речь про asm / C / C++, а область технических задач при разработке максимально близка к железу. С другой стороны, если вы в контексте IoT на каком-нибудь Orange Pi в Python-коде будете работать с GPIO, оно тоже в какой-то мере low level. Наверное.

В общем, границы плавают, у каждого своя линейка, особенно если подходить к теме со стороны программирования. Железо может быть внутри класса вполне high level (та же Raspberry Pi 3B/B+ "просто" компьютер же), но писать для него строго на asm, шевеля руками каждый бит портов. Ну вы поняли.

---

Допустим, вы романтик и тонко чувствующая гармонию мира личность. И вас штырят компьютерные 1970-е. Тогда железо было железным, лампы мигали, не было шшшаблонов, отцов их, проектирования. Эпоха рассвета идей (на которых по сию пору живём) и решений. Тогда были созданы [PDP-11](https://en.wikipedia.org/wiki/PDP-11) и [Cray-1](https://en.wikipedia.org/wiki/Cray-1), вышла на пик популярности [БЭСМ-6](https://ru.wikipedia.org/wiki/БЭСМ-6). Начала восход Intel со своим первым [Intel 4004](https://en.wikipedia.org/wiki/Intel_4004), за ней в кильватер вошла AMD. Включилась ARPAnet. Вылез из детских штанишек UNIX. IBM сотворила сначала флоппики, потом винты (кстати, "винт" потому, что внутреннее название проекта было ["Winchester"](https://www-03.ibm.com/ibm/history/exhibits/storage/storage_3340.html)).

![Обложка TIME, 2 апреля 1965 года](/assets/images/1101650402_400.jpg "Обложка TIME, 2 апреля 1965 года")

Программисты не отставали. Ритчи разработал C, народ осваивал пришедший в разум ALGOL (который 68), FORTRAN начал завоёвывать планету (его далеко не сразу приняли), COBOL вообще поглотил всех, Prolog, Pascal, Smalltalk, BASIC, LISP, Forth — всё это либо создано в 1970-х, либо к тому десятилетию вошло в полную силу. Фактически 90% современного программирования тогда уже было реализовано. А если не реализовали, то описали на бумаге и отложили. Особый спорт — спрашивать в барной болтовне, мол, как думаешь, когда появилось ООП, когда ты уже мог ООПисать код? Многие считают, что в 1990-х, рубеж категории *"ну, когда Ленин умер, а Сталин всех карал"*.

Короче говоря, эпоха, в которую все окончательно смирились с тем, что компьютеры всерьёз и надолго, а сделать с ними можно всё, что ночью в сухую голову приходит. Интересное время, к которому фиг прикоснёшься *руками*. И железок не осталось почти (только маленькие шкафы в музеях и у энтузиастов), и эмуляторы фигня какая-то без вкуса и запаха. Всё не то. Но до меня вдруг дошло.

Посмотрите ассортимент и возможности современных SBC. Посмотрите ассортимент и возможности компьютеров 1970-х. Одно и то же! Пусть флопсы и похожи на средних сферических попугаев по больнице, но давайте сверим [старое](https://ru.wikipedia.org/wiki/FLOPS#Обзор_производительности_реальных_систем) с, например, [Raspberry Pi](https://medium.com/@ghalfacree/benchmarking-the-raspberry-pi-3-b-plus-44122cf3d806). Raspberry Pi 3 B+ — это класс Эльбрус-2 и Cray-1. А, скажем, [Arduino](https://hmbd.wordpress.com/2016/08/24/speed-comparisons-for-arduino-unonano-and-due/) — БЭСМ-6 и CDC 6600. Хорошо, по флопугаям железо близенько. Сейчас на нём торренты и видео делают, а 45 лет назад космос и физику осваивали.

Окей, что с языками? Ну... 1970-е — эдакий рубеж. Если ты хотел сделать что-то хардкорное с максимальной оптимизацией, использовал ассемблер. Если не хотел (а и такой хардкор многих подзадолбал), использовал высокоуровневые ЯП, коих уже был целый зоопарк (и половина программистов планеты только тем и занималась, что переносила компиляторы с одной платформы на другую). Но, мне кажется, современный даже RISC-ассемблер представляет собою язык высокого уровня первого поколения, так сказать. Ну, да, мнемоники не так натуральны, как keywords C или Java. Но если в БЭСМ-6 [было](http://www.mailcom.com/besm6/instset_ru.shtml) около 60 команд, то в ARM их почти 180 (и это не считая condition code). Т.ч. любой каприз реализуем с *достаточным* комфортом. А, ну и да, OS уже тоже вовсю были, к их процедурам из кода тоже уже обращались.

Окей, что с вводом/выводом? Сейчас всё круче, конечно. Никаких тебе перфокарт или магнитных лент, результат работы тоже не на принтере выбивается. Однако, первый популярный [emacs](https://en.wikipedia.org/wiki/Emacs) (ещё не GNU) Столлман написал в 1976 году. Да и вообще, уже в 1964 году у DEC был расчудесный [Precision CRT Display Type 30](http://www.computinghistory.org.uk/userdata/files/digital-precision-crt-display-type-30.pdf) (PDF), фотографию которого ниже я взял со страницы [computerhistory.org](http://www.computerhistory.org/pdp-1/8955eff5ea3981a242732be99f335026/).

![DEC Precision CRT Display Type 30](/assets/images/dec.pdp-1.chm_pdp-1_restoration_type_30_display_in_alignment.2005.102663948.lg_.jpg "DEC Precision CRT Display Type 30")

Иными словами, хоть с некоторыми условностями, но заход по ssh на плату и редактирование асм-кода в каком-нибудь nano / vim с последующим выводом результата на текстовую консоль тоже неплохо напоминает работу в старых терминалах. Собственно, это и есть терминал, просто более модный и с минимизированной рутиной подключения, листания, просмотра истории и т.д. Если на то пошло, то [Xerox Alto](https://en.wikipedia.org/wiki/Xerox_Alto) с его GUI появился уже в 1973 году.

Наконец, периферия. Бери железку, подключай, читай даташит, мигай диодами, верти мотором. Да и то не очень аутентично будет, т.к. драйвера умели писать уже тогда, потому конечные потребители всё же редко работали с внешним оборудованием настолько хардкорно. Тем не менее, при желании можно и так развлекаться.

Что в итоге? SBC 2018 года по всем показателям (кроме размера, надёжности и энергопотребления) здорово близки ЭВМ 1970-х. Хочешь почувствовать себя в шкуре чувака, который сначала в тетрадях писал программу кодами / мнемониками, потом собирал, запускал и пырился на портянку текста (затем чертыхался и дампил регистры) — запускай ChtoNibud Pi и вперёд. Романтично. Хардкорно. Почти аутентично. Захотел побыть сумасшедшим инженером из старого фантастического фильма — будь им, можно даже сотню диодов приделать, чтобы красиво и нарядно.

---

Второй аспект, но не менее значимый, такой: иногда хочется делать технически выверенные до последней точки продукты. Продуктики. Чтобы каждая инструкция в дело, чтобы оптимально было до упора, ни байта назад. А современные продукты для бизнеса часто делаются по другому принципу (настолько детально и настолько многократно озвученному со всех площадок за последние лет тридцать, что останавливаться для раскрытия не буду). Более того, нередко у вас и нет настолько плотного контроля над системой, чтобы обеспечить требуемую душе точность работы. Ну да, заоптимизировал ты функцию. А соседний вызов популярного фрейморка сожрёт и не подавится. Заоптимизировал и его. Окей, а теперь базу загнули, всё просело. С базой разобрался... ну блин, теперь оказывается, что фронтенд работает медленнее, чем отрабатывают вызовы API, потому настолько быстрыми им и не надо быть. В общем, всюду клин.

В SBC же (и прочей мелочи) оптимальный, плотный и выверенный код — требование техническое. Чуть ли не обязательное. Железку не интересуют ваши пламенные речи на тему того, как в современном мире важно и приоритетно быстро говнокодить. У неё, например, 512KB на борту, привет, шевели извилиной. Ну добро, возьмём Raspberry Pi 3 B+, там 1GB ОЗУ. Но если торкнет со всей силы, вы начнёте ваять мелкие поделки, на каждую из которых по $50 не напасёшься. А оно ещё и одноядерным будет. А и память не сверхбыстрая. И частота будет не в гигагерцах, ага. Кайф же!

---

Повторю: это *мои* причины. И да, я не зарабатываю этим, потому могу помечтать, пофантазировать, не окунаясь с головой в профессиональную разработку для MCU со всем, что свойственно любой профессиональной разработке (сроки, начальство, говнокод, удивляющие заказчики и т.п.). Но... слушайте, всё это хороший способ не закиснуть и погрузиться в ещё одно измерение программирования.

Добро пожаловать в 1970-е.
