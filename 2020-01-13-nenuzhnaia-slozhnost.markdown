---
layout: post
title: "Ненужная сложность"
date: 2020-01-13 17:20:00 +0300
categories: talk
---

Скину наброском дамп мысли сюда, чтобы подкорку не царапало. Одно из наблюдений за новичками: бойцы для решения задач используют всю доступную им сложность языка. Задрав пример, можно сказать, вместо `2 + 2` наваяют десяток функций с лямбдами, хитрожопой реализацией шаблонов и умной зачисткой памяти. Другое наблюдение (уже после чтения разного рода старого кода от старых инженеров): овердофига задач можно решить именно с помощью `2 + 2`. И решают, что характерно. Третье наблюдение (после листания старых журналов и старых реализаций алгоритмов): прям вот овердофига задач можно решить с помощью `2 + 2`. Потом я пару раз не смог ответить на вопрос *«зачем?»* в ответ на моё (ща утрирую) *«а почему вы не используете вот эту вот новую кленовую мегафичу?»*.

После всего этого как-то задумчивее стал смотреть на языки, в которых ну очень много всякого... красивого и условно удобного. Всё это не требуется для решения реальных задач реального мира. Это требуется самим программистам. По сути у нас есть четыре проблемы:
* организация кода;
* читабельность кода;
* доступность / понятность механизмов работы с памятью;
* с некоторых пор (что породило новое недопоколение языков) доступность / понятность механизмов работы с N ядрами.

Немалая часть этих проблем уже решена в языках *«прошлого»* -- Pascal, C, Erlang, Fortran, Ada. Быть может, не в той степени, в которой привыкли современные разработчики на JavaScript, Ruby и Python, но степень избалованности у каждого своя, да.

Так вот... так вот... какая же тут мысль... я-то её чую, но как промычать... Понимаете, легко погрязнуть в водовороте фич, забыв в процессе, а нафига вот это вот всё. Да, всё можно написать в машинных кодах. Никто этим в здравом уме для коммерческой разработки заниматься не будет, если не требуется жастачайшая оптимизация под очень куцый ресурс. Примерно та же история с ассемблером сейчас. И т.д. Но есть некоторая граница, после которой действительная нужда в фиче сменяется уже привычкой в синтаксическом сахаре потому, что люди меняются, времена другие и т.п.

А около этой границы языки, которых уже достаточно для решения большинства задач. В том числе и потому живы и всё ещё популярны языки *«прошлого»*. Если вам важно (первично, приоритетно) решить задачу, а не решить её как-то комфортно, модно, приятно, вам хватит этих условных C. Думаете, большой и сложный проект не написать на этом? Да вот вам тот же [Nginx](https://github.com/nginx/nginx) -- как писался, так и пишется на C. Проект большой, успешный. Несколько более исторический пример -- [Quake](https://github.com/id-Software/Quake).

---

Продолжу мычание. Для меня начинает быть проблемой конвертация задач даже не в код, это мелочь, а в предлагаемые языками конструкции. Не потому, что их много или они плохо понятны. Потому, что спотыкаюсь об *«а зачем?»* -- я свёл задачу к `2 + 2`. И эту. И вон ту. И мой коллега так же сделал. И вот в этом отлаженном боевом коде тоже вижу такое же. Да, мы могли написать это сложнее. Красивее. Эстетичнее с позиции использования сахара (инструкции сгенерировались бы те же, впрочем, если не хуже). Но зачем? Зачем? Зачем?

В ЖЖ давным-давно был дядька из Republic of Belarus (чёт опасаюсь неправильно написать, бацьки трепетно относятся к тому, пишешь ты *«в Белоруси»* или *«на Беларуссии»*), он делал софт для БПЛА. Не помню, насколько то было промышленное (военка краем мелькала, кажется), но его птичка летала, на ноуте показывалась реалтаймовая карта, маршруты строились и соблюдались, вообще всё выглядело няшно и не на коленке. И всё это было во времена, когда народ ещё AltaVista вовсю пользовался, а не Google. Так вот, все офигели, когда он сказал, что софт пишут на Pascal. 

Первое издание [Dennis Ritchie, Brian Kernighan. *The C Programming Language*] -- 236 страниц небольшого формата. Прочитал? Садись и пиши код. Вирт в 1971 году в [*The Programming Language Pascal*] вообще 28-ю страницами обошёлся, а [*ISO Pascal Standard*] 1974..1991 занимает 226 страниц. Прочитал? Садись и пиши код. Про Lisp и Forth вообще молчу.

Нет, умом я понимаю. Мы теперь код можем писать семью парадигмами и в пяти измерениях, а вместо двадцати строк будет одна (т.к. те двадцать строк теперь приныканы в стандартной библиотеке под горой абстракций, породив ещё сто строк, дабы уместиться во все углы красивостей). Только зачем? Какая именно и как звучащая проблема всем этим решается?

---

Чем дальше, тем меньше времени в моей жизни занимает именно кодирование. В большинстве случаев все эти акты написания кода на работе (вне работы какой только фигнёй не забавляюсь) сводятся к двум областям:
* в голове / на бумагах проработаны функции / алгоритмы, их осталось тупо транслировать в инструкции;
* долблюсь в какую-нибудь не сработавшую дребедень.

Всё. Код -- финальный акт моей деятельности как программиста. И чаще всего я не мыслю... м... конструкциями обобщённого программирования, borrow checker'ами, лямбдами и прочим. Всё это возникает в финале, когда задача *уже* решена и её надо перевести в какой-нибудь язык. И как-то с каждым годом всё больше раздражает, когда вместо прямой и быстрой трансляции я вынужден жонглировать очередными изобретениями изобретателей *«так, давайте изменим синтаксис цикла... нет, лучше так... а если так? ой, слишком олдово, давайте вот так! чёрт, тоже фигня, а если ещё так? и вот так, да»* (да, всё ещё изумляюсь идиотии ранних версий Swift). Безусловно, в этом тоже часть зарплаты, платят частично и за это умение кропотливо и уместно перевести в выбранный стек с бумаги -- оно же и является самым прямым признаком работы программиста. Безусловно, я *должен* хорошо всё это знать.

Только как же задолбало переизобретение одного и того же под разным фантиками. То у нас нет `null`, то есть, то нет, то теперь есть в трёх видах, то снова нет, но на самом деле есть, называется иначе, то мы снова его испугаемся. А давайте вокруг *«структур с функциями»* наворотим ОООООПЭЭЭЭЭ!!!11 Пусть все заманаются в каждом языке отвечать на собеседованиях на вопросы вроде *«а вот какой метод вызовется, если вы отнаследуете жопу от часовни»*.

При этом, повторю мысль, очень, очень занимает вопрос: как, блин, наши *«отцы и деды»* без всей этой пердолябии планету морфировали и в космос летали? Является ли обязательной вся эта обвязка для решения задач? Насколько реально повысилось качество кода от этого (а не от того, что у нас теперь горсть линтеров и чекеров)?

---

Размышляя обо всём подобном важно отрешиться от гиковской программистской симпатии к разной технической мешанине. Важно сдвинуть внутренний приоритет на, снова скажу, решение задачи. Задачи приходят извне. Программирование ради программирования -- это ну такое, на диване баловаться, пока мама не видит. А когда сдвинешь, понимаешь, что твоим заказчикам (от дяди Вахтанга до Социалистической Империи Капиталистических Рептилоидов) вот ну совершенно наплевать, используешь ты исключения или у тебя функции в `int` код ошибки возвращают. Вот совершенно. Это вообще не проблема. И не микропроблема. И даже не нанопроблема. И деньги выделяются не на это.

Т.е. ваша задача (как профессионального программиста) сделать всё *правильно* (**и** задачу решить, **и** с позиции программирования не начудить кривыми лапами с обгрызенными ногтями), но всё-таки... всё-таки всем пофиг по большому счёту (пока результат умещается в ТЗ, да ещё и с запасом), если выключить в себе перфекциониста и любовь к эстетике.

Собственно, и мне самому гораздо интереснее сваять что-то, что будет десять лет гоняться за Годзиллой, периодически ему наваливать, по пути собирать огурцы с морковкой, да ещё в самые удачные моменты провокационно демонстрировать флаг державы, потом словит, надаёт щелбанов и перекрасит в розовое. Просто... это же и есть работа. Платят за Годзилла Хантера. И смотреть потом прикольно на то, как твой миллион инструкций заставляет успешно шевелиться огромную машину.

Во, вроде словил ключевую мысль (чувство, ощущение): всё больше задалбывает то, что между решением на бумаге и огромной машиной на полигоне всё более толстый слой синтаксического сахара, синтаксической моды, программистского барокко и рококо. Тратишь драгоценное время на то, чтобы хотя бы ознакомиться со списком фич, 9/10 которых использовать не будешь, но должен знать. Каждая вторая кажется какой-то ненужной фигнёй (каковой и оказывается, пусть её раз пять на 100К LoC и включит какой-нибудь гуру-теоретик (а после него злобно выключит гуру-практик)). Каждую пятую в следующем релизе языка будут костылить, т.к. она оказалась не просто ненужной, но и опасной (и вой наступивших на грабли поднимается со всех уголков StackOverflow).

Потом лет за пять все снова запутаются в этих палках с синей изолентой, придумают такой же язык (пока ещё без палок), в нём снова всё иначе назовут, и всё заново на следующий цикл, т.к. авторов неимоверно задолбит сообщество, требующее взаимоисключающих свистелок и перделок, требующее кнопок *«сделай мне хорошо»*, в ужасе бегущее от `for (int i = ..)` (и в упор не желающее замечать миллион этих `for` под ковром -- что-то типа гринписовцев в пластиковых шубках, предпочитающих не думать о том, сколько пластиковых деревьев ради шубок вырублено), после чего история повторится ещё тысячу раз.

---

Как-то так. Когда уже будет нормальная зима, блин.
