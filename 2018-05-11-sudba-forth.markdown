---
layout: post
title: "Судьба Forth"
date: 2018-05-11 16:40:06 +0300
categories: forth
---
Таки [*"Как плюсы и джава убили такой чудесный язык?"*](https://twitter.com/mr_mig_by/status/994812790220222464) Что пошло не так?

**Начнём** с начала. Чтобы язык стал массовым, он должен быть понятен массам (целевой аудитории). Чем больше масса (с максимумом в количество людей на планете), тем более массовый и "победивший" язык. Практика показывает, что на вершине этой метрики оказываются языки, в текущий момент наиболее близкие бытовому представлению о программировании. Эти же языки применяются в учёбе, что наращивает инерцию дальнейшего использования людьми.

BASIC разработан Курцем и Кемени в 1964 году как язык для студентов-непрограммистов. Pascal разрабатывался как упрощение Алгола с потенциалом обучения студентов структурному программированию (Вирт [отмечал](http://pascal.hansotten.com/niklaus-wirth/recollections-about-the-development-of-pascal/) успех в этом 30 лет спустя, отметив также отсутствие поддержки индустрией) — да до сих в ряде вузов на Паскале кодят. Python используется сейчас первым языком для начинающих, как и JavaScript (книги *"(Python\|JavaScript) for kids"* популярны). Это четыре сверхпопулярных массовых языка. И это четыре языка, которые могла освоить условная тётя Глаша из отдела инвентаризации столов и стульев. Вот вам и массовость.

У Forth уже его постфиксная нотация превратила массовость в недостижимую Фудзияму. И нужда в понимании стековой машины. Все действительно массовые языки исключают понимание работы памяти, стеков, регистров и т.п. Это слишком круто для тёти Глаши. А упрощать никто и не собирался. Соответственно, пока на всю планету было 17 программистов с тремя физмат высшими образованиями на каждого, Форт чувствовал себя прекрасно. Когда за клавиатуру сели Глаши, мир начал меняться.

---

**Второе** начало в компенсации человеческого фактора. Иначе говоря, даже лучший в мире программист будет безбожно косячить. От этого устали как сами программисты (ну кому нравится час скармливать стопку перфокарт, чтобы обнаружить непробитую дырочку), так и корпорации (вот весело в масштабах IBM размышлять о том, как твои 10000 программистов половину времени не продукт делают, но баги правят). Потому языки развиваются в стороны *"наиболее раннее обнаружение ошибки на стадии разработки"* (анализаторы, IDE), *"средства языка для обработки ошибок"* (исключения), *"изгнание провоцирующих конструкций"* (война с =/==, например), *"приближение к бытовому мышлению"* (скажем, та же инфиксная нотация, удобная людям, но неудобная парсерам).

Интересным следствием является поддержка кровавым энтерпрайзом расчудесного (шучу, на самом деле скукота) языка Java. Энтерпрайз требует валового производства ремесленного продукта. Если в мире 1M складов, должны быть 100K разработчиков, которые напишут 10K складских программ. Бизнес такой, особенно бизнес взаимоинтеграции этой свалки на уровне государственных тендеров. Так вот Java оказалась идеальна. Язык простой и безопасный, можно нанимать пушечное мясо. Язык достаточно строгий, потому адовая формализация процессов вместе с автоматикой тестирования и прочим компенсирует адочек в финале. Да, внутри кака, но работает. Язык достаточно развит (включая библиотеки), чтобы покрывать нужды энтерпрайза. Ура-ура. Недавно попадалась статья бойца из IBM, разбирались причины факапов. Так вот современный разработческий IBM — это интерфейс к Бангалору. Зато дёшево. Зато работает, если нанять не 10K, но 20K чуваков. Писать будут долго и мучительно, но ЗАТО ДЁШЕВО.

И снова это не про Forth. Язык, в котором вас никто не защищает ни от чего. Что написал, то в лоб и прилетит. Учитывая забавный синтаксис и стековые особенности... Скажем так, пока я осваивал первые 10 страниц учебника, завесил намертво [gforth](https://www.gnu.org/software/gforth/) на Андроиде тоже 10+ раз.

---

**Третье** начало в универсальности. Универсальность — свойство языка, позволяющее X лет на Y архитектурах решать Z задач. Сюда стреляет всё. И поддержка массами, пишущими сотую библиотеку разбора командной строки. И поддержка корпорациями, решающими языками свои задачи (привет, Go, привет, Swift). И возможность создавать проекты любого масштаба (с каждым годом всё толще и толще). И включение народом или корпорациями поддержки новых явлений вроде цветных дисплеев и виртуальной реальности. Обилие учебной литературы. Включение в программу вузов (SICP на Python, эх). Выявить один решающий фактор невозможно, особенно во времена интернета. Не будь [Райана Даля](https://en.wikipedia.org/wiki/Ryan_Dahl), были бы сейчас Node.js-программисты вместо jQuery-верстальщиков?

C, C++, Java, Python, Fortran — их объединяет также и расположенность к созданию библиотек, фреймворков, модулей, пакетов. Нафигачил, нафигачил, выложил, оно десятки лет живёт и всё ещё тёплое. Культура накопления и распространения. За эти же десятки лет набирается такая огромная гора решений задач на множестве платформ, что чуть ли не любая ваша обычная задача уже решена. Ну или вы можете её решить, подмазав кирпичик маслом, а шурупчик напильником.

Forth в этом контексте чистый лист. Y архитектур — да, хоть в настенной кукушке. X лет — да, он настолько прост, что его левой пяткой портируют из года в год на новое железо и в новые OS. Z задач — нет. Нечем. Forth не для прямого решения задач. Он для создания инструментов, которыми вы будете решать свои задачи. Нюанс, как мне кажется, в том, что отлично решена будет именно ваша задача, а вот сделать из решения "фреймворк"... не на Forth. Утомитесь любой привычный в других языках код писать с нуля. Утомитесь от нужды писать тысячи строк на языке, на котором эти тысячи строк неудобно читать. Forth позволяет за год сделать катану именно под вашу руку и под ваш стиль. C++ позволяет за месяц (допустим) написать завод по производству стандартных офицерских парадных шашек по сто штук в день, а на сдачу киоск Союзпечати. Разница универсальности в этом.

---

Вообще же у меня возникло впечатление, что авторам Forth и Forth-сообществу это и не требовалось. Массовость? Ну, побыли массовыми, когда программирование компьютеров было программированием микропроцессоров и микроконтроллеров, которым занимались специалисты. Компенсация человечности? А зачем, если фортофил готов каждый символ няшить и тешить до победы? Универсальность? Изначально не закладывалась, к ней не стремились и дальше. Удовольствие и ниша Forth — создание небольших чрезвычайно "ёмких" и "плотных" решений для крохотных (по нынешним меркам, конечно, а так-то IBM System/360 могли и комнату занять целиком) железок. Доить из Forth коммерцию? Как понимаю, и без того во взятых рамках плохо не было, контракты с NASA не копеечные, надеюсь.

Потому я не могу согласиться с тем, что язык убили. Он без борьбы отдал поле, за которое грызлись поколения BASIC (венцом Visual Basic) и Pascal (венцом Delphi), уехал в провинцию и там возделывает грядку.
