---
layout: post
title: "Терминологический импринтинг"
date: 2020-07-31 12:30:00 +0300
categories: talk
---

Как оно нередко бывает у мелких и душных душою людей, я неравнодушен к точности и уместности употребляемой терминологии (да и вообще слов, если говорить и о быте). Было дело, одно совещание почти сорвал, завяв слушать бред, что нёс чем-то там руководитель. Открыть хотя бы страничную статью в Википедии у него времени нет, а вот час для безграмотного полива чужих ушей нашёлся.

Короче говоря, считаю тему важной, потому особое внимание уделяю тому, что и как говорят junior'ы.

---

Так вот, представьте, что вам требуется обучить... скажем, водителя. Сейчас задача *как можно быстрее* поставить его на местные маршруты, выдав нужную категорию, но вы уже понимаете, что смотреть следует дальше, потому через N лет видите человека на международных перевозках, да ещё и с нехилой степенью свободы (а у водителей разных ситуаций случается немало).

Напрашивающийся древний путь муштры: учим сразу и только той фуре, на которой будет, заодно пусть зубрит районы города, через которые маршрут, ну и всё. Через месяц-другой боевая единица.

В общем, ровно тем же занимаются и те, кто штампует джуниоров-практиков. Минимум теории, учи синтаксис языка, заучи кнопки в IDE, научись пользоваться <del>навигатором</del> StackOverflow, всё, пшёл в окопы, там доучишься.

Всё бы хорошо, только вот город у вас необычный. Центростороннее движение. У машин кабина сзади. А руководства написаны на местном диалекте пушту. Вы успешно выпустили местного начинающего водителя, но не заложили ли вы минное поле под дальние планы? Сколько будущих аварий спровоцировано особенностями *первого опыта*, ведь в других странах и даже городах всё несколько иначе?

---

Почему мины? Потому, что у меня есть убеждение, которое не могу подкрепить наблюдениями научного сообщества и прочими пруфами, от которых рационально мыслящий логик (коими, несомненно, являются абсолютно все разработчики) тут же уверует. Cам свой крохотный уголок мира немножко наблюдал и вывел немножко статистики: первый терминологический набор несёте по жизни как память о первом поцелуе. Если вам не объясняли сразу же, почему не нормально перед поцелуем петь гимн СССР, так оно в подкорку и упадёт, после чего могут потребоваться годы, чтобы вытравить привычку.

Слова пристают и того крепче.

На днях один знакомый задал вопрос, который я не сразу понял, т.к. не мог совместить смысл вопроса со словом *«протокол»*. Когда копнул память, вздрогнул. Дело в том, что в Swift есть [Protocols](https://docs.swift.org/swift-book/LanguageGuide/Protocols.html), которые неформально в документации описываются так:
> A protocol defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be adopted by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to conform to that protocol.

Ничем знакомым не повеяло? Ах да, это же *интерфейс* (*interface*) -- термин, которому уже 35+ лет, который вошёл в мир практики через **Objective-C** с 1984 года, упрочнился через **Java** с 1995 года, а ещё есть в **Delphi**, в **C\#**, в **Go**... и даже в **UML**. И даже при обсуждении **COBOL** в 1992 году уже звучало:
> COBOL objects and their interfaces must be designed to be easily reused in a variety of contexts.

С середины 1990-х термин начинает всё чаще возникать уже у теоретиков и практиков ООП, а с 2000-х окончательно устаканивается в культуре программистов (впрочем, это вовсе не означает, что у академиков ООП многолетняя дискуссия завершилась) окончательно.

Тем любопытнее то, что на странице протоколов Swift'а слово *«interface»* не попадается ни разу. И в самом деле, зачем.

---

Задача учителя (ментора, куратора, тренера, лектора, you name it) в том, чтобы у обучаемого выстроилась правильная (как минимум, актуальная) последовательность от общего к частным. Вам не нужен абсолютно весь спектр, оно интересно только для увлечённых собирать варианты *«давайте угадаем, как же автор стопицотого ЯП решил назвать ассоциативный массив»* (я так как-то собирал забавы ради все доступные мне варианты написания *петрушки* в английских рукописях XIV..XV вв.: *persil*, *percil*, *percely*, *persel*, *percyle*, *persile*, *persele*, *percelie*, *percelly* и т.д. -- ну вдруг кому было интересно).

Удобно на практике внедрить в голову такую ментальную структуру:
1. («Associative array / Ассоциативный массив») **Академический уровень** -- сюда складывать самые общие термины, обычно это вот та теория, которую так не любят. Отсюда же брать слова, которые разыскивать в индексах научных работ.
2. («Dictionary / Словарь») **Общепрограммистский уровень** -- здесь живут слова, которыми называются наиболее общие и употребляемые штуковины. Нередко это то же, что и академический уровень, но на жаргоне или как-то исторически сложилось. Отсюда брать слова, чтобы разговаривать с другими программистами или гуглить *«а как мне в Swift сделать интерфейс?»* (но не *«а как мне в C++ сделать протокол?»*).
3. **Инструментальный уровень** -- здесь слова, которыми вот то общее называется в том, на что вы сейчас смотрите. Отсюда брать слова для общения в кругу пользователей инструмента.
    1. (Map, HashMap) Java.
    2. (Dictionary) Swift.
    3. (dict) Python.
    4. ...

При желании сюда можно навертеть ещё уровней, измерений и ответвлений (что хорошо, т.к. вы будете представлять мир точнее), но для новичков оптимальным считаю три уровня. Если человек совсем вводный, академический уровень можно не заполнять, но остановиться временно на общем и инструментальном.

---

Так вот. Если вы учите водителя по максимально сокращённой схеме, хотя бы следите за тем, чтобы слова распределялись по правильным уровням (если обучение идёт от общего к бесконечно удалённому частному -- привет нелюбителям советской школы образования -- у вас такой проблемы обычно нет). Новичкам нередко свойственно распространять новое знание максимально широко. Он легко [и молча, паразит такой,] влепит этот *протокол* на академический уровень, с уверенностью всезнайки на экзамене по структурам данным (в отрыве от ЯП) будет вещать про HashMap, а в худшем случае ещё много лет будет при изучении других языков шептать под нос *«эк ОНИ некрасиво НАШ public static void назвали...»*

Помогайте джунам. Следите за тем, чтобы каждое слово приземлилось правильно. В IT всё больше самоучек, прошедших первый важный этап обучения через заднекабинные фуры с мануалами на пушту, а учителей с линейкой не было. Если пустить процесс на самотёк, однажды обнаружите, что не только вы сами не можете понять Васю, но также друг друга не могут понять Степан, Олег и Софья. А это уже проблема. Особенно если Вася, Степан, Олег и Софья -- вся ваша команда для проекта на год жизни.

PS. Эта краткая заметка именно *про слова*. Выбор первого языка влияет и на многое другое (для затравки можно [почитать](https://www.joelonsoftware.com/2005/12/29/the-perils-of-javaschools-2/) Спольски 2005 года), но это другое тема для других эссе.
