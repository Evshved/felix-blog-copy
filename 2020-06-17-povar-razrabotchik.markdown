---
layout: post
title: "Повар-разработчик"
date: 2020-06-17 12:00:00 +0300
categories: talk
---

У начинающих очень часто нет знания (и быстро его добыть сложно) о том, что всё-таки должен знать и уметь junior. Почти все разговоры, курсы и учебники вокруг разработки упираются в написание кода или в решение задач, завершающееся написанием кода. Иначе говоря, разработка ПО в голове сводится к программированию (здесь к *«кодированию»*), начинающий упорно зубрит какой-нибудь ЯП с каким-нибудь фреймворком, а потом сталкивается с тем, что этого мало.

Я вас спасу. Но сначала про поваров.

Мемуары и биографии поваров читать приятно и полезно. Лечит (как и другие книги подобного толка) от упрощённого взгляда на любую профессию. До прочтения вы могли считать, что поваренное искусство -- это сварить яйцо всмятку и бутерброд сделать, после увидите, что *правильный* повар -- это и выбор продуктов (вместе со знанием их подноготной), и умение уместно подготовить их, и владение огромным ассортиментом кухонного оборудования, и само приготовление, и сочетание блюд, и составление меню, и правильная подача, и правильное употребление, и составление диеты, и большая культура вкуса, вида и аромата, и знание традиций, и умение организовать себя и команду (по мере роста).

Так и разработка.

*Правильный* программист -- он и программист, и тестировщик, и менеджер, и админ, и архитектор, и дизайнер, и экономист. Всего понемножку (кроме программирования, понятно), повару не требуется быть кандидатом биологических наук (чтобы выбрать картоху на деруны) или стоять в витрине Эрмитажа (чтобы эстетически красиво расположить пятна сметаны в борще), но это всё должно быть.

Итак, junior. Попробую наглядно по его шагам за рабочий день показать, что всё требуемое органично выводится из того, чем человек занят.

---

**Включает компьютер**. Программы работают в/на компьютерах. Собственно, и рабочий день (минус совещания и обед) проходит тоже у компьютера. Соответственно, программист должен хотя бы в общих чертах представлять, что такое компьютер и как им уверенно пользоваться (нет, чтение VK не входит).

Польза тут двойная:
* вы быстрее выполняете свою работу (а не ищете 10 минут под гиканье болельщиков способ узнать, в какой вы сейчас директории находитесь -- true story);
* вы понимаете, почему ваша программа работает медленно / быстро (удивительно, но совсем не все готовы платить за медленно работающий софт).

Потому хорошо бы усвоить азы *«Компьютерной архитектуры»* (aka *«Архитектура компьютера»*, а в школьной программе ещё и *«Архитектура ПК»*). Достаточное понимание можно обозначить на понимании *«почему процессор с двумя ядрами не означает автоматически удвоение скорости выполнения программ относительно одноядерного процессора»*. Ну или сами придумайте себе что-нибудь подобное.

---

**Думает, чем бы ему заняться**. Программист включается в процессы, в цепочку производства. Если вы не единственный айтишник в компании, добро пожаловать на большую кухню: Иван закупает продукты, Пётр моет / чистит, Игнат варит, Семён жарит, Олег принимает заказы, Фёдор за кассой, Олег управляет, Ольга снимает пробу и грозит черпаком, если Саша сахар не положила или Женя пересолила, Валерий же сидит за столиком и критикует.

Создание ПО ровно так же разбито на этапы, а этапы являются частями тех магических *«процессов»* (ах, вы слышали, у них процессы не налажены! -- да что вы говорите! ужас-то какой!).

В разных процессах оно может отличаться, но интуитивная последовательность вот такая:
* сбор требований к ПО -- менеджеры;
* создание ТЗ к ПО -- менеджеры, технические писатели;
* создание плана работ (последовательность задач) -- менеджеры, руководители разработки;
* решение задач -- программисты, дизайнеры, фронтендеры;
* обеспечение инфраструктуры / условий эксплуатации -- админы, программисты;
* проверка качества (тестирование) -- тестировщики;
* ввод в эксплуатацию, сопровождение -- админы, программисты, служба поддержки.

Всё несколько сложнее, понятное дело, вовсе не так стройно, также выбранная методология (да, их совсем не одна) разработки влияет на итерации (да и в процессы нередко включается вообще всё от наличия печенек на кухне до обработки заявки на декрет), но даже на такой простой схеме видно, что программист не один в поле воин и должен хотя бы не мешать остальным делать дело.

Потому хорошо бы понимать следующее:
* из чего состоит создание ПО;
* какие бывают методологии разработки, чем занимаются разные люди в разных методологиях.

Если совсем уж широко смотреть на мир, речь в этой подглавке про *«Инженерию программного обеспечения»* -- любопытствующие могут полистать одноимённый учебник Соммервилла.

---

**Открывает редактор**. Едва ли не каждый этап разработки нынче покрыт пачкой инструментов (к слову, операционная система тоже ваш инструмент), которые следует знать и которыми следует уметь пользоваться:
* в редакторе вы пишете текст программы;
* компилятором (пока отвлечёмся от наличия интерпретаторов) транслируете в понятный компьютеру машинный код;
* отладчиком отлаживаете;
* профилировщиком находите узкие места;
* упаковщиком собираете в пакет;
* проекты достаёте из системы контроля версий;
* по ходу дела шастаете в командную строку, чтобы там выполнить что-то полезное;
* заодно в тасктрекере отмечаете статус выполнения задач;
* и т.п.

Всё это инструменты. Всё это нужно освоить. Повар, не умеющий пользоваться ножиком, никому не нужен.

---

**Набирает текст программы**. Очевидный этап рабочего дня программиста, он же основной в жизни junior'а, но требует отдельного разговора, т.к. здесь уже речь именно про знания и умения из *«Программирования»* -- вот это вот всё от азбуки булевой алгебры до архитектуры многоуровневых приложений. В интересах этого эссе важно понимать следующее: программирование самая важная часть, но всё же только часть разработки ПО.

---

**Проверяет код**. Тоже очевидный этап -- нельзя сказать, что вы решили задачу, если не убедились в правильности решения. Потому программисты (во всяком случае, нормальные) тоже тестируют. Тестирование -- занятие по сложности недалеко ушедшее от программирования. Попробуйте для начала ответить (себе, а не мне) на вопрос *«а как вообще договориться о том, что такое правильное решение, а что такое неправильное?»* -- тысячи страниц посвящены.

Но junior'у должно на первых этапах хватить следующего:
* знание о том, что тестирование сложное и многообразное -- полистайте [статьи](https://ru.wikipedia.org/wiki/Тестирование_программного_обеспечения) Википедии об этом;
* программист *должен* проверять свои решения (когда вы станете руководителем разработки, без жалости увольняйте тех, кто раз за разом отправляет тестировщикам решения, которые даже запуститься не могут);
* для упрощения тестирования существуют библиотеки, инструменты, методологии (с этим тоже следует познакомиться).

---

**Выкатывает программу**. Называется разными словами (вы могли слышать популярное *«deploy»* (на русском это *«деплой»*)), но суть одна -- у программ есть жизненный цикл, наиболее близкий к вам выглядит так:
* собрать проект так, чтобы его можно было удобно / правильно скопировать на компьютеры, на которых проект будет работать;
* уметь штатно обновлять версию проекта (заменять старую новой);
* в случае проблем уметь откатить эту выкатку, вернув систему в исходное состояние.

Выглядит просто, а по факту одно из самых болезненных во всём вот этом, потому вокруг едва ли не индустрия образовалась с полушаманскими практиками (почитайте про [Continuous delivery](https://en.wikipedia.org/wiki/Continuous_delivery) и [Continuous integration](https://en.wikipedia.org/wiki/Continuous_integration)). Просто представьте, что бежите марафон, а рядом бегущая команда меняет вам сердце или лёгкие. Очевидно, всем очень хочется, чтобы вы не упали на пыльный асфальт, подёргивая лапками и глядя затухающим взглядом на ботинки лихорадочно бегающих вокруг вас ~~адм~~... хирургов. Кстати, если таки упадёте, это называется *«опять эти безрукие прод уронили»* (про безруких не запоминайте, по нынешним временам токсичность).

Представили? А теперь представьте, что эту операцию проводят над всеми участниками марафона (современное серверное ПО часто раскатывается на десятки-сотни серверов), при этом зрители (посетители сайта, например) в идеале даже заметить не должны.

А ещё ваша программа на компьютере должна работать. А не падать, не забивать всё файлами логов (журналирование -- когда каждый чих записывается в файл, дабы потом можно было понять, почему двигатель не заводится), не забирать все ресурсы (Out of memory error -- то, что вы однажды обязательно увидите), не мешать работать другим программам и т.п.

Назову эту тему *«Эксплуатацией»* и очень прошу относиться к ней очень серьёзно. Тогда у вас есть шанс получить от админов на какой-нибудь Новый год бутылку вкусного шампанского. Или молока.

---

Резюмирую. Первый комплекс практических знаний junior'а состоит из:
* Архитектура компьютера.
* Инженерия программного обеспечения.
* Методологии разработки программного обеспечения.
* Инструменты.
* Программирование.
* Тестирование.
* Эксплутация.

Как juinior'у всему этому научиться без боли и страданий, да ещё так, чтобы не внутри уже боевого процесса (и потому без особых поблажек или возможностей месяц поточить зубы об темку)? Хорошего ответа я не знаю. Сами посудите, если бы в природе существовал такой ответ, да ещё и в виде доступного понятного курса для начинающих, все (включая вас) о нём знали бы и друг другу рекомендовали. Но такого нет.

Потому попробуйте листать / читать книги разного качества, зато довольно обширные по количеству затрагиваемых тем:
* Чарльз Петцольд. *Код: тайный язык информатики* -- азы, основы, фундамент.
* Фредерик Брукс. *Мифический человеко-месяц* -- классика о процессах, о создании ПО, о том, как через тернии в тернии.
* Стив Макконнелл. *Совершенный код* -- о том, как программировать. 
* Пассиг Катрин, Яндер Йоханнес. *Программирование без дураков* -- разухабистая книга для тех, кто не осилил предыдущую.

Набирайте в голову ключевые слова и концепции, активно гуглите, активно читайте статьи / книги и смотрите доклады с конференций. Рано или поздно, но начнёт складываться система знаний, а дальше уже легче.

---

PS. Совсем смелым духом и любящим, чтобы каталог был размером с джип, советую посмотреть в сторону [Software Engineering Body of Knowledge](https://en.wikipedia.org/wiki/Software_Engineering_Body_of_Knowledge) (энто разработчикам) и [Project Management Body of Knowledge](https://en.wikipedia.org/wiki/Project_Management_Body_of_Knowledge) (энто менеджерам) -- учитаться по самую макушку.

PPS. Совершенно верно, пункта **Ушёл домой с работы** нет. :)
